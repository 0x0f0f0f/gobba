<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Minicaml__Puritycheck (minicaml.Minicaml__Puritycheck)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc %%VERSION%%"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> â€“ <a href="../index.html">minicaml</a> &#x00BB; Minicaml__Puritycheck</nav><h1>Module <code>Minicaml__Puritycheck</code></h1></header><dl><dt class="spec value" id="val-level_purity"><a href="#val-level_purity" class="anchor"></a><code><span class="keyword">val</span> level_purity : <a href="../Minicaml/Types/index.html#type-puret">Minicaml.Types.puret</a> <span>&#45;&gt;</span> <a href="../Minicaml/Types/index.html#type-puret">Minicaml.Types.puret</a> <span>&#45;&gt;</span> <a href="../Minicaml/Types/index.html#type-puret">Minicaml.Types.puret</a></code></dt><dd><p>&quot;level out&quot; the purity of two values</p></dd></dl><dl><dt class="spec value" id="val-infer"><a href="#val-infer" class="anchor"></a><code><span class="keyword">val</span> infer : <a href="../Minicaml/Types/index.html#type-expr">Minicaml.Types.expr</a> <span>&#45;&gt;</span> <a href="../Minicaml/Types/index.html#type-evalstate">Minicaml.Types.evalstate</a> <span>&#45;&gt;</span> <a href="../Minicaml/Types/index.html#type-puret">Minicaml.Types.puret</a></code></dt><dd><p>Infer the purity of an expression. Note: this is a naive approach. This function is an abstract interpretation of expressions over primitives and environments.</p><dl><dt>parameter pt</dt><dd><p>The primitives table</p></dd></dl><dl><dt>parameter paraml</dt><dd><p>If inside a lambda, the list of parameters</p></dd></dl><dl><dt>parameter env</dt><dd><p>An environment, needed to infer whether lazy expressions are pure or not</p></dd></dl></dd></dl><dl><dt class="spec value" id="val-lookup"><a href="#val-lookup" class="anchor"></a><code><span class="keyword">val</span> lookup : <a href="../Minicaml/Types/index.html#type-ide">Minicaml.Types.ide</a> <span>&#45;&gt;</span> <a href="../Minicaml/Types/index.html#type-evalstate">Minicaml.Types.evalstate</a> <span>&#45;&gt;</span> <a href="../Minicaml/Types/index.html#type-puret">Minicaml.Types.puret</a></code></dt><dt class="spec value" id="val-infer_assignment"><a href="#val-infer_assignment" class="anchor"></a><code><span class="keyword">val</span> infer_assignment : <a href="../Minicaml/Types/index.html#type-evalstate">Minicaml.Types.evalstate</a> <span>&#45;&gt;</span> <span>(bool * <a href="../Minicaml/Types/index.html#type-ide">Minicaml.Types.ide</a> * <a href="../Minicaml/Types/index.html#type-expr">Minicaml.Types.expr</a>)</span> <span>&#45;&gt;</span> <a href="../Minicaml/Types/index.html#type-evalstate">Minicaml.Types.evalstate</a></code></dt><dt class="spec value" id="val-infer_assignment_list"><a href="#val-infer_assignment_list" class="anchor"></a><code><span class="keyword">val</span> infer_assignment_list : <span><a href="../Minicaml/Types/index.html#type-assignment_type">Minicaml.Types.assignment_type</a> list</span> <span>&#45;&gt;</span> <a href="../Minicaml/Types/index.html#type-evalstate">Minicaml.Types.evalstate</a> <span>&#45;&gt;</span> <a href="../Minicaml/Types/index.html#type-evalstate">Minicaml.Types.evalstate</a></code></dt></dl></div></body></html>